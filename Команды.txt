MOV приёмник, источник
Допустим только один косвенный элемент


ADD a, b ; a = a + b
SUB a, b ; a = a - b


add byte [number], 4; добавляем значение 4 к байту по адресу number

ADC, SBB  - сложение и вычитание с учетом бита переноса
ADC a, b; a = CF + a + b
SBB a, b; a = a - b - CF


В контексте арифметических операций часто используются пары регистров (EDX:EAX)

mov ax, 0xffff	; AX = 0xFFFF
mov dx, 0	; DX = 0
add ax, 8	; AX = AX + 8
adc dx, 0	; AX = 0 + AX + CF


INC DEC

INC o1
DEC o1

Флаг CF не изменяется

inc word[number]


Команды работы с отрицательными числами
NEG - МЕНЯЕТ ЗНАК
CBW - КОПИРУЕТ СЕДЬМОЙ БИТ РЕГИСТРА AL В AH
CWD - КОПИРУЕТ СТАРШИЙ БИТ РЕГИСТРА AX В DX
CDQ - КОПИРУЕТ СТАРШИЙ БИТ РЕГИСТРА EAX В РЕГИСТР EDX
CWDE - КОПИРУЕТ СТАРШИЙ БИТ РЕГИСТРА AX В РЕГИСТР EAX

целочисленное умножение и деление
MUL DIV
IMUL IDIV - для знаковых чисел


//////////////////////////////////////////
MUL a;					//
					//
(a)(r/m8) * AL -> AX			//
(a)(r/m16) * AX -> DX:AX		//
(a)(r/m32) * EAX -> EDX:EAX		//
//////////////////////////////////////////
IMUL умножает целые числа со знаком и может использовать один, два или три операнда.
Если операнд один, то поведение аналогично MUL
Если два, то первый операнд умножается на второй и становится приёмником. Первый операнд должен быть регистром!
IMUL EDX, ECX; EDX = EDX * ECX
IMUL EDX, 6; EDX = EDX * 6
Если операнда три, то второй умножится на третий и результат в первый
IMUL EDX, ECX, 7; EDX = ECX * 7

DIV a
AX / (a)(r/m8) -> AL, остаток AH
DX:AX / (a)(r/m16) -> AX, остаток DX
EDX:EAX / (a)(r/m32) -> EAX, остаток EDX

Логические команды
AND o1, o2; o1 = o1 and o2, где o1 o2 адреса, регистры, значения

mov al, 1
and al, 0

OR - аналогично and
XOR - <-/->

NOT - инверсия битов
NOT (r/m8/m16/m32)
